{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Repository","text":""},{"location":"Hardware/","title":"Hardware","text":"<p>This page is not completed</p> <p>Learning material for this section has not been created/implemented</p>"},{"location":"Mechanical/","title":"Mechanical","text":"<p>This page is not completed</p> <p>Learning material for this section has not been created/implemented</p>"},{"location":"Software/Advanced/","title":"Advanced Section","text":"<p>This section is dedicated to Intermediate-Advanced Robotics Programming. It is intended for individuals who have established a strong foundation in First Robotics programming. More complex topics such as (but not limited to) PID controllers, computer vision, and autonomous routines will be covered.</p> Seemingly Easy <p>While some concepts in this section appear to be very simple in practice, this section dives deeper into the theory of how each concept functions, its usecases, and its drawbacks.</p>"},{"location":"Software/Advanced/pid/","title":"PID Controllers","text":"<p>The PID (Proportional-Integral-Derivative) controller is a widely used control algorithm in the field of robotics. It is an essential tool for controlling motor speed, position, and many other dynamic systems. </p>"},{"location":"Software/Advanced/pid/#control-terms","title":"Control Terms","text":"<p>A PID Controller is consisted of three terms that control its output.</p> Letter Term Description P Proportional proportional to the current error between the desired setpoint and the measured process variable. I Integral accumulates the error over time and provides a long-term correction to the control signal. D Derivative proportional to the rate of change of the error signal. It provides a damping effect to the control signal <p>Definitions</p> <ul> <li>Setpoint: The desired value of the process variable.</li> <li>Process Variable: The value of the variable being controlled.</li> <li>Control Signal: The output of the PID controller.</li> </ul>"},{"location":"Software/Advanced/pid/#nomenclature","title":"Nomenclature","text":"<p>The following nomenclature will be used to describe the PID controller's equations in this section.</p> Notation Definition e(t) Error u(t) Control signal r(t) Setpoint y(t) Process variable Variable Definition Kp Proportional gain Ki Integral gain Kd Derivative gain"},{"location":"Software/Advanced/pid/#proportional-term","title":"Proportional Term","text":"<p>The Proportional term is responsible for adjusting the control output proportionally to the current error. This means that the larger the error, the larger the corrective action applied to the system. </p> Kp Proportional Gain <p>The Proportional gain, represented by the variable K determines the strength of this correction. A higher value of Kp results in a stronger correction for a given error.</p> <p>The control signal of the proportional term is calculated as follows:</p>"},{"location":"Software/Advanced/pid/#ut-kpet","title":"u(t) = Kpe(t)","text":"<p>The proportional gain is multiplied by the error to produce the control signal.</p> <p>A simple P controller can be modelled as follows:</p> <p></p> A Physics Analogy <p>In Hooke's Law, the force applied by a spring is proportional to the displacement from its equilibrium position. Similarly, the P value in a PID controller determines the proportional response of the controller to the error signal, which is the difference between the desired setpoint and the actual measured value.</p> <p>Just as a stiffer spring will apply a larger force for the same amount of displacement, a higher P value will result in a larger correction for the same amount of error. However, if the P value is set too high, just like a spring that is too stiff, the controller's response will become too sensitive and can lead to overshooting or oscillations. Therefore, the P value needs to be carefully tuned to provide the appropriate proportional response to the error signal, resulting in stable and accurate control.</p>"},{"location":"Software/Advanced/pid/#integral-term","title":"Integral Term","text":"<p>The Integral term is responsible for adjusting the control output based on the accumulated error over time. This means that the longer the error persists, the larger the corrective action applied to the system.</p> FRC Use <p>Integral gain is not recommended for FRC use. It is usally better to use a feedforward controller to eliminate steady-state error. It is included here for completeness.</p> Ki Integral Gain <p>The Integral gain, represented by the variable Ki determines the strength of this correction. A higher value of Ki results in a stronger correction for a given error.</p> <p>The control signal of the integral term is calculated as follows:</p>"},{"location":"Software/Advanced/pid/#ut-ki-etdt","title":"u(t) = Ki \u222be(t)dt","text":"<p>The integral gain is multiplied by the integral of the error to produce the control signal.</p>"},{"location":"Software/Advanced/pid/#the-steady-state-error","title":"The Steady State Error","text":"<p>Steady State Error</p> <p>When the system is close the setpoint in steady-state, the proportional term may be too small to pull the output all the way to the setpoint, and the derivative term is zero. This can result in what is called a steady-state error.</p>"},{"location":"Software/Advanced/pid/#definition","title":"Definition","text":"<ul> <li>Steady-state error is the difference between the setpoint and the process variable when the system has reached a steady-state.</li> </ul>"},{"location":"Software/Advanced/pid/#graph","title":"Graph","text":"<p>Solution to Steady State</p> <p>Using the Integral term we can solve this issue. Because the integral term accumulates the error over time, it will continue to increase until the error is zero. This means that the integral term will continue to increase until the steady-state error is eliminated.</p> <p>Seen in the figure below</p> <p></p>"},{"location":"Software/Advanced/pid/#derivative-term","title":"Derivative Term","text":"<p>The Derivative term is responsible for adjusting the control output based on the rate of change of the error. This means that the faster the error changes, the larger the corrective action applied to the system.</p> Kd Derivative Gain <p>The Derivative gain, represented by the variable Kd determines the strength of this correction. A higher value of Kd results in a stronger correction for a given error.</p> <p>The control signal of the derivative term is calculated as follows:</p>"},{"location":"Software/Advanced/pid/#ut-kd-detdt","title":"u(t) = Kd de(t)/dt","text":"<p>The derivative gain is multiplied by the derivative of the error to produce the control signal.</p> FRC Use <p>The derivative term is less used in frc applications.</p>"},{"location":"Software/Advanced/pid/#how-it-works","title":"How it works","text":"<p>The derivative term works by calculating the slope of the error signal over time, which gives an indication of how quickly the error is changing. This information can be used to predict the future behavior of the system and to adjust the control output accordingly.</p> <p>When the error is changing rapidly, the derivative term produces a large correction signal, which helps to dampen the system's response and prevent overshoot. On the other hand, when the error is changing slowly, the derivative term produces a smaller correction signal, which allows the system to respond more quickly to changes in the setpoint.</p> <p>Predictive</p> <p>The derivative term can be thought of as a \"predictive\" element in the PID controller, since it uses information about the rate of change of the error signal to anticipate future changes in the process variable.</p>"},{"location":"Software/Advanced/pid/#tuning-a-pid-controller","title":"Tuning a PID Controller","text":"<p>There are multiple different ways to tune a PID controller.</p> <p>For our purposes we use a trial and error method. There are alternatives such as the Ziegler-Nichols method, but they are not covered here.</p> <p>Time Consuming</p> <p>This method can be time-consuming and requires a good understanding of the system's behavior.</p> <p>Manual tuning involves adjusting the proportional, integral, and derivative gains manually by trial and error. This method involves observing the system's response to changes in the setpoint and adjusting the gains to achieve the desired response. </p>"},{"location":"Software/Advanced/pid/#summary","title":"Summary","text":"<p>A PID (proportional-integral-derivative) controller is a control algorithm used in control systems to regulate a process variable, to a desired setpoint. The controller calculates an error signal, which is the difference between the setpoint and the actual value of the process variable. The controller then uses three components: the proportional term, the integral term, and the derivative term, to adjust the control output and bring the process variable closer to the setpoint.</p> <p>The Terms</p> <ul> <li>The proportional term provides a control output proportional to the error signal</li> <li>The integral term takes into account the past error and accumulates it to reduce the steady-state error</li> <li>The derivative term considers the rate of change of the error signal to predict the future behavior of the system. </li> </ul> <p>By using all three components (tuned correctly), a PID controller can respond to changes in the process variable quickly and accurately, and maintain stable control in the face of disturbances and other external factors.</p>"},{"location":"Software/Commands/","title":"Commands","text":"<p>Abstract</p> <p>Official Documentation on Command Based programming</p> <p>Commands represent actions the robot can take. Commands run when scheduled, until they are interrupted or their end condition is met. Commands are represented in the command-based library by the Command interface. </p> <p>Note</p> <p>Commands are a fundamental building block of almost all of the actions a robot can take. They have to ability to be bound to a button and activate/control different subsystems</p>"},{"location":"Software/Commands/exampleCommand/","title":"exampleCommand","text":"<p>``` java 'Example Command' // Copyright (c) FIRST and other WPILib contributors. // Open Source Software; you can modify and/or share it under the terms of // the WPILib BSD license file in the root directory of this project.</p> <p>package edu.wpi.first.wpilibj.templates.commandbased.commands;</p> <p>import edu.wpi.first.wpilibj.templates.commandbased.subsystems.ExampleSubsystem; import edu.wpi.first.wpilibj2.command.CommandBase;</p> <p>/* An example command that uses an example subsystem. / public class ExampleCommand extends CommandBase {   @SuppressWarnings({\"PMD.UnusedPrivateField\", \"PMD.SingularField\"})   private final ExampleSubsystem m_subsystem;</p> <p>/*    * Creates a new ExampleCommand.    *    * @param subsystem The subsystem used by this command.    /   public ExampleCommand(ExampleSubsystem subsystem) {     m_subsystem = subsystem;     // Use addRequirements() here to declare subsystem dependencies.     addRequirements(subsystem);   }</p> <p>// Called when the command is initially scheduled.   @Override   public void initialize() {}</p> <p>// Called every time the scheduler runs while the command is scheduled.   @Override   public void execute() {}</p> <p>// Called once the command ends or is interrupted.   @Override   public void end(boolean interrupted) {}</p> <p>// Returns true when the command should end.   @Override   public boolean isFinished() {     return false;   } } ```</p>"},{"location":"Software/Commands/properties/","title":"Command Properties","text":"<p>In addition to the four lifecycle methods, each Command in the WPILib library has three properties that can be set to customize its behavior. These properties are defined by getter methods and should always return the same value with no side effects.</p>"},{"location":"Software/Commands/properties/#getrequirements","title":"<code>getRequirements()</code>","text":"<p>Declares any subsystems that the command controls as requirements. This property ensures that no more than one command requires a given subsystem at the same time, preventing conflicts such as two different pieces of code attempting to set the same motor controller to different output values.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>getRequirements()</code> method in the relevant command class</li> <li>Calling <code>addRequirements()</code> method</li> <li>Using the <code>requirements</code> vararg parameter</li> </ul> Adding Requirements to a Command <pre><code>public class ExampleCommand extends CommandBase {\nprivate final ExampleSubsystem m_subsystem;\npublic ExampleCommand(ExampleSubsystem subsystem) {\nm_subsystem = subsystem;\n// Use addRequirements() here to declare subsystem dependencies.\naddRequirements(subsystem);\n}\n}\n</code></pre>"},{"location":"Software/Commands/properties/#runswhendisabled","title":"<code>runsWhenDisabled()</code>","text":"<p>Specifies whether the command may run when the robot is disabled. By default, the value is <code>false</code>, meaning the command will be canceled when the robot is disabled and attempts to schedule it will do nothing. Returning <code>true</code> will allow the command to run and be scheduled when the robot is disabled.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>runsWhenDisabled()</code> method in the relevant command class</li> <li>Using the <code>ignoringDisable</code> decorator</li> </ul> Adding Requirements to a Command <pre><code>public class ExampleCommand extends CommandBase {\npublic ExampleCommand() {\n}\nboolean runsWhenDisabled(){\nreturn true // Allows the command to run while disabled\n}\n}\n</code></pre>"},{"location":"Software/Commands/properties/#getinterruptionbehavior","title":"<code>getInterruptionBehavior()</code>","text":"<p>Defines what happens if another command sharing a requirement is scheduled while this one is running. The default behavior is <code>kCancelSelf</code>, meaning the current command will be canceled and the incoming command will be scheduled successfully. If <code>kCancelIncoming</code> is returned, the incoming command\u2019s scheduling will be aborted and this command will continue running.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>getInterruptionBehavior()</code> method in the relevant command class</li> <li>Using the <code>withInterruptBehavior()</code> decorator (Java, C++).</li> </ul>"},{"location":"Software/Commands/structure/","title":"Structure of a Command","text":""},{"location":"Software/Commands/structure/#states","title":"States","text":"<p>When writing a command, you need to specify what the command should do in each of its possible states. To do this, you override the <code>initialize()</code>, <code>execute()</code>, and <code>end()</code> methods. The command should also be able to tell the scheduler when it has finished executing by overriding the <code>isFinished()</code> method.</p> <p>end() Method</p> <p>The <code>end()</code> method actually provides a parameter to check if the command ended normally, or was interrupted.</p> <pre><code>    void end(boolean interrupted){\nif (interrupted == True){\n// The command has been interrupted\n}\nelse{\n// The command has ended as expected\n}\n}\n</code></pre> <p>Tip</p> <p>If a command is not finishing correctly, make sure the <code>isFinished()</code> method returns true when the command should terminate</p>"},{"location":"Software/Commands/structure/#default-behavior","title":"Default Behavior","text":"<p>If you don't want to specify any special behavior for these methods, they are already provided with default behavior. For example, <code>initialize()</code>, <code>execute()</code>, and <code>end()</code> do nothing by default, while <code>isFinished()</code> returns false by default. This creates a command that runs indefinitely until it is interrupted.</p> <p>Methods in Summary</p> <p><code>initialize()</code> --&gt; Called once per scheduling  <code>execute()</code> --&gt; Called every scheduler cycle that the command is scheduled  <code>end()</code> --&gt; Runs once per termination (at the end)  <code>isFinished()</code> --&gt; Called every scheduler cycle (if true --&gt; terminate command)</p>"},{"location":"Software/Commands/Composition/compositions/","title":"Command Compositions","text":"<p>Commands in the command-based library are capable of performing a variety of robot tasks. However, when advanced functionality requiring extended sequences of robot tasks or coordination of multiple robot subsystems is required, users are encouraged to use the command composition functionality.</p> <p>Question</p> <p>Where do you think 4541's Software Team uses compositions the most?</p> One Answer <p>4541, along with pretty much every FRC team, uses command compositions in their autonomous routines. You will learn more about this in the Autonomous Section!</p> <p>Component Commands</p> <p>Component Commands --&gt; Any command</p> <p>A command composition is a combination of one or more commands that allows code to be kept cleaner and simpler. Component commands can be written independently of the code that combines them, reducing complexity.</p> <p>Command compositions are commands themselves, which allows them to be further composed as a recursive composition. This means a command composition can contain other command compositions as components, enabling powerful and concise inline expressions.</p> <p>Commands Themselves</p> <p>Because they are commands themselves, compositions inherit the standard properties of commands.</p>"},{"location":"Software/Commands/Composition/types/","title":"Composition Types","text":""},{"location":"Software/Commands/Composition/types/#repeatedly-composition","title":"Repeatedly Composition","text":"<p>Repeatedly Composition</p> <p>The <code>repeatedly()</code> decorator, backed by the <code>RepeatCommand</code> class restarts the command each time it ends, so that it runs until interrupted.</p> <p>Decorator</p> <pre><code>Command repeats = exampleCommand.repeatedly();\n</code></pre> <p>The command is restarted by calling the command's <code>execute()</code> method again. The command is interrupted by calling the command's <code>end()</code> method. </p> <p>Canceling a Repeatedly Command</p> <pre><code>Command repeats = exampleCommand.repeatedly();\n// Assuming the command is scheduled\nrepeats.cancel();\n</code></pre>"},{"location":"Software/Commands/Composition/types/#sequential-composition","title":"Sequential Composition","text":"<p>Arguably one of the most important composition type, the <code>SequentialCommand</code> class runs a list of commands in sequence. The command ends when the last command in the sequence ends.</p> <p>Sequential Compositions can be created in a variety of ways:</p> Using SequentialCommand Constructor.andThen() DecoratorSequentialCommandGroup Class <pre><code>Command sequential = new SequentialCommand(exampleCommand, exampleCommand2);\n</code></pre> <pre><code>Command sequential = exampleCommand.andThen(exampleCommand2);\n</code></pre> <pre><code>Command sequential = new SequentialCommandGroup(exampleCommand, exampleCommand2, exampleCommand3);\n// OR\nCommand sequential = new SequentialCommandGroup()\nsequential.addCommands(exampleCommand, exampleCommand2, exampleCommand3);\n</code></pre> <p>What's the difference between a SequentialCommand and SequentialCommandGroup?</p> <p>The main difference between the two is that a <code>SequentialCommandGroup</code> allows you to group multiple commands together as a single command. This means that you can create a complex series of actions, like moving an arm, then closing a claw, then raising the arm again, and execute them all as a single command.</p>"},{"location":"Software/Commands/Composition/types/#parallel-composition","title":"Parallel Composition","text":"<p>Another important composition type, the <code>ParallelCommand</code> class runs a list of commands in parallel. The command ends when the last command in the sequence ends.</p> <p>Parallel Compositions can be created in a variety of ways:</p> Using ParallelCommand Constructor.alongWith() DecoratorParallelCommandGroup Class <pre><code>Command parallel = new ParallelCommand(exampleCommand, exampleCommand2);\n</code></pre> <pre><code>Command parallel = exampleCommand.alongWith(exampleCommand2);\n</code></pre> <pre><code>Command parallel = new ParallelCommandGroup(exampleCommand, exampleCommand2, exampleCommand3);\n// OR\nCommand parallel = new ParallelCommandGroup()\nparallel.addCommands(exampleCommand, exampleCommand2, exampleCommand3);\n</code></pre> <p>What's the difference between a ParallelCommand and ParallelCommandGroup?</p> <p><code>ParallelCommandGroup</code> is used when you want to group commands together as a single logical unit. <code>ParallelCommand</code> is used when you want to run multiple commands independently and concurrently.</p>"},{"location":"Software/Java/","title":"Java","text":"<p>Java is a popular and versatile programming language that is used to create a wide range of applications, from mobile apps to enterprise-level software systems. Our robot is programmed in 100% Java, so you'll need to become even more familiar with the language.</p>"},{"location":"Software/Java/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>Before you can start coding in Java, you'll need to set up your development environment. Here are the basic steps:</p> <ol> <li>Download and install the Java Development Kit (JDK) from the official website.</li> <li>Download and install an Integrated Development Environment (IDE), for programming the bot, we use Visual Studio Code, aka Vscode.</li> <li>Create a new project in Vscode and start coding.</li> </ol>"},{"location":"Software/Java/classes/","title":"Classes","text":"<p>Classes are the building blocks of object-oriented programming (OOP) in Java. A class is a blueprint for creating objects, which are instances of the class. In this guide, we will cover the basics of Java classes.</p>"},{"location":"Software/Java/classes/#creating-a-class","title":"Creating a Class","text":"<p>To create a class in Java, you use the <code>class</code> keyword followed by the name of the class. Here's an example:</p> <pre><code>public class Person {\nString name;\nint age;\n}\n</code></pre> <p>In this example, we have created a class called <code>Person</code>. The class has two instance variables: <code>name</code> and <code>age</code>.</p>"},{"location":"Software/Java/classes/#instance-variables","title":"Instance Variables","text":"<p>Instance variables are variables that belong to each instance of a class. Each instance has its own copy of the instance variables. Here's an example:</p> <pre><code>Person person1 = new Person();\nperson1.name = \"John\";\nperson1.age = 25;\nPerson person2 = new Person();\nperson2.name = \"Jane\";\nperson2.age = 30;\n</code></pre> <p>In this example, we have created two instances of the <code>Person</code> class: <code>person1</code> and <code>person2</code>. We have set the <code>name</code> and <code>age</code> instance variables for each instance.</p>"},{"location":"Software/Java/classes/#constructors","title":"Constructors","text":"<p>Constructors are used to create instances of a class. Here's an example of a constructor in the <code>Person</code> class:</p> <pre><code>public Person(String name, int age) {\nthis.name = name;\nthis.age = age;\n}\n</code></pre> <p>In this example, we have defined a constructor that takes two parameters: <code>name</code> and <code>age</code>. The constructor initializes the <code>name</code> and <code>age</code> instance variables using the <code>this</code> keyword.</p>"},{"location":"Software/Java/classes/#using-constructors","title":"Using Constructors","text":"<p>Here's an example of how to use the <code>Person</code> constructor:</p> <pre><code>Person person1 = new Person(\"John\", 25);\nPerson person2 = new Person(\"Jane\", 30);\n</code></pre> <p>In this example, we have used the <code>Person</code> constructor to create two instances of the <code>Person</code> class: <code>person1</code> and <code>person2</code>. We have passed in values for the <code>name</code> and <code>age</code> parameters.</p>"},{"location":"Software/Java/helloWorld/","title":"Hello World","text":"<p>The \"Hello World\" program is a classic example used to introduce beginners to programming languages. Create a new file in Vscode namd <code>helloWorld.java</code> and then paste this program into the file.</p> <pre><code>public class helloWorld {\npublic static void main(String[] args) {\nSystem.out.println(\"Hello, World!\");\n}\n}\n</code></pre> <p>Run the program by clicking the the play button on the top right of your screen, it should output \"Hello, World!\" to the console. Try it!</p>"},{"location":"Software/Java/methods/","title":"Methods","text":"<p>Methods are used to define the behavior of a class. Here's an example of a method in the <code>Person</code> class:</p> <pre><code>public void sayHello() {\nSystem.out.println(\"Hello, my name is \" + name + \" and I am \" + age + \" years old.\");\n}\n</code></pre> <p>In this example, we have defined a method called <code>sayHello()</code>. The method uses the <code>name</code> and <code>age</code> instance variables to print a message to the console.</p>"},{"location":"Software/Java/variables/","title":"Variables","text":""},{"location":"Software/Java/variables/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Variables are used to store values in Java. Here's how you can declare and initialize a variable:</p> <pre><code>int myNumber = 42;\n</code></pre> <p>In this example, <code>myNumber</code> is a variable of type <code>int</code> that is initialized with the value <code>42</code>. Java has several different data types, including:</p> <ul> <li><code>int</code>: used for storing integers (whole numbers).</li> <li><code>double</code>: used for storing floating-point numbers (numbers with decimal points).</li> <li><code>boolean</code>: used for storing <code>true</code> or <code>false</code> values.</li> </ul>"},{"location":"Software/Subsystems/","title":"Subsystems","text":"<p>A Subsystem is a single motor or group of motors and sensors that work together to accomplish one certain task. An example of a subsystem would a a drivetrain, shooter, intake, etc.</p>"},{"location":"Software/Subsystems/buildingASubsystem/","title":"Building a Subsystem","text":""},{"location":"Software/Subsystems/buildingASubsystem/#creating-your-subsystem","title":"Creating your subsystem","text":"<p>To create a subsystem in Java, you use the <code>class</code> keyword followed by the name of the manipulator you are making a subsystem for and lastly the subsystem class must extend SubsystemBase. Here's an example:</p> <pre><code>public class Shooter extends SubsystemBase {\n}\n</code></pre> <p>In this example, we have created a class called <code>Shooter</code> in order to create a subsystem for a shooter. For the remainder of creating this subsystem, or in this example, shooter all code will lie within this class. </p>"},{"location":"Software/Subsystems/buildingASubsystem/#the-periodic-function","title":"The periodic function","text":"<p>All subsystems have a periodic function:</p> <pre><code>public class Shooter extends SubsystemBase {\npublic void periodic() {\n}\n}\n</code></pre> <p>A periodic function is a function that is designed to perform a specific task or set of tasks in a subsystem. This function is ran at a constant interval (about every 20 milliseconds) and can be used for: Constantly checking a value like a sensor value, projecting a value onto smart dashboard, etc.</p> <pre><code>public class Shooter extends SubsystemBase {\npublic void periodic() {\nif (getSensor() == true) {\nSystem.out.println(\"Sensor pushed!\")\n}\n}\n}\n</code></pre> <p>In this example, when the sensor is pushed it prints \"Sensor pushed!\".</p>"},{"location":"Software/Subsystems/motorStates/","title":"Motor States","text":""},{"location":"Software/Subsystems/motorStates/#motor-states","title":"Motor states","text":"<p>A motor state refers to the current state or status of a motor within a subsystem of the robot. We will make three diffrent example states with an enum that cantains ON, OFF, and REVERSED.</p>"},{"location":"Software/Subsystems/motorStates/#setting-motor-states","title":"Setting motor states","text":"<pre><code>    public enum shooterMotorState {\nON,\nOFF,\nREVERSED\n}\npublic shooterMotorState shooterAngleMotorState = shooterMotorState.OFF;\npublic shooterMotorState shooterSpeedMotorState = shooterMotorState.OFF;\n</code></pre> <p>To define what each of these states do we use function to set the motor states using the enum we made previously.</p> <pre><code>    public void setShooterAngleMotorState(shooterMotorState state) {\n// set the current state\nthis.shooterAngleMotorState = state;\n// set motor state\nswitch (state) {\ncase ON:\n// On\nthis.shooterAngleMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterAngleMotor.set(0);\nbreak;\ncase REVERSED:\n// Reversed\nthis.shooterAngleMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterAngleMotorState(shooterAngleMotorState.OFF);\n}\n}\npublic void setShooterSpeedMotorState(shooterMotorState state) {\n// set the current state\nthis.shooterSpeedMotorState = state;\n// set motor state\nswitch (state) {\ncase ON:\n// On\nthis.shooterSpeedMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterSpeedMotor.set(0);\nbreak;\ncase REVERSED:\n// Reversed\nthis.shooterSpeedMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterSpeedMotorState(shooterSpeedMotorState.OFF);\n}\n}\n</code></pre> <p>These functions define how each state value will manipulate the motor. The on state makes the motor go clockwise at max speed (the max speed is 1) and off makes the motor not move. </p>"},{"location":"Software/Subsystems/motorStates/#checkup","title":"Checkup!","text":"<p>Here is what your subsystem should look like so far:</p> <pre><code>public class Shooter extends SubsystemBase {\npublic Shooter() {\nthis.shooterAngleMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterSpeedMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterAngleMotor.setInverted(true);\nthis.shooterSpeedMotor.setInverted(false);\nthis.shooterAngleMotor.setSmartCurrentLimit(50);\nthis.shooterSpeedMotor.setSmartCurrentLimit(75);\n}\npublic CANSparkMax shooterAngleMotor = new CANSparkMax(1, MotorType.kBrushless);\npublic CANSparkMax shooterSpeedMotor = new CANSparkMax(2, MotorType.kBrushless);\nprivate DigitalInput shooterButton = new DigitalInput(1);\npublic enum shooterMotorState {\nON,\nOFF,\nREVERSED\n}\npublic shooterMotorState shooterAngleMotorState = shooterMotorState.OFF;\npublic shooterMotorState shooterSpeedMotorState = shooterMotorState.OFF;\npublic void setShooterAngleMotorState(shooterMotorState state) {\nthis.shooterAngleMotorState = state;\nswitch (state) {\ncase ON:\nthis.shooterAngleMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterAngleMotor.set(0);\nbreak;\ncase REVERSED:\nthis.shooterAngleMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterAngleMotorState(shooterAngleMotorState.OFF);\n}\n}\npublic void setShooterSpeedMotorState(shooterMotorState state) {\nthis.shooterSpeedMotorState = state;\nswitch (state) {\ncase ON:\nthis.shooterSpeedMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterSpeedMotor.set(0);\nbreak;\ncase REVERSED:\nthis.shooterSpeedMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterSpeedMotorState(shooterSpeedMotorState.OFF);\n}\n}\n}\n</code></pre>"},{"location":"Software/Subsystems/motorsAndSensorInit/","title":"motorsAndSensorInit","text":""},{"location":"Software/Subsystems/motorsAndSensorInit/#motors-and-sensors-in-a-subsystem","title":"Motors and sensors in a subsystem","text":"<p>In the following example subsystem we will be programming a simple subsystem that contains two motors and one limit switch sensor. This example subsystem will be called shooter but when making a subsystem it should describe what task the group of motors work together to accomplish.</p>"},{"location":"Software/Subsystems/motorsAndSensorInit/#initialization-of-subsystem-motors","title":"Initialization of subsystem motors","text":"<p>As stated we will be creating an example subsystem with two motors. The initializiation of the motors will lie within the subsystem class. In this example there will be one motor for the angle of the shooter and one motor for the speed of the shooter. Again this is just an example.</p> <pre><code>public class Shooter extends SubsystemBase {\npublic CANSparkMax shooterAngleMotor = new CANSparkMax(1, MotorType.kBrushless);\npublic CANSparkMax shooterSpeedMotor = new CANSparkMax(2, MotorType.kBrushless);\n}\n</code></pre> <p>These lines of code create new instances of the CANSparkMax class to control specific motors identified by their ID (1 and 2) and assigns them to the shooterAngleMotor and shooterSpeedMotor variables for further use in the program. The motor name should be a brief explanation of what the motor does. This motor initialization should be written the desired subsystem class the motor will be used for.</p>"},{"location":"Software/Subsystems/motorsAndSensorInit/#initialization-of-subsystem-sensors","title":"Initialization of subsystem sensors","text":"<p>All subsystems have a periodic function:</p> <pre><code>public class Shooter extends SubsystemBase {\npublic CANSparkMax shooterAngleMotor = new CANSparkMax(1, MotorType.kBrushless);\npublic CANSparkMax shooterSpeedMotor = new CANSparkMax(2, MotorType.kBrushless);\nprivate DigitalInput shooterButton = new DigitalInput(1);\n}\n</code></pre> <p>This line creates a new instance of the DigitalInput class and asigns it to the variable buttonSensor and should be physically plugged into port one on the roborio. The Sensor name should be a brief explanation of what the sensor detects.</p>"},{"location":"Software/Subsystems/motorsAndSensorInit/#subsystem-function","title":"Subsystem function","text":"<p>The subsystem function takes the same name as the subsystem class and can be used to set sparkMax functions. A sparkMax is the brain of the motor.</p> <pre><code>public Shooter() {\nthis.shooterAngleMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterSpeedMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterAngleMotor.setInverted(true);\nthis.shooterSpeedMotor.setInverted(false);\nthis.shooterAngleMotor.setSmartCurrentLimit(50);\nthis.shooterSpeedMotor.setSmartCurrentLimit(75);\n}\n</code></pre> <p>In this example both motor's idle modes are set to brake. This makes the motors enter break mode when they are not moving. There are many other idle modes to choose from. This function also inverts shooterAngleMotor, which makes it spin the opposite way, and it sets the current limit on the angle motor to 50 and the speed motor to 75.</p>"},{"location":"Software/Subsystems/subsystemVariables/","title":"Subsystem Variables","text":""},{"location":"Software/Subsystems/subsystemVariables/#subsystem-variables","title":"Subsystem variables","text":"<p>We will be creating variables tell us what the speed of our motors are, their positions, etc.</p>"},{"location":"Software/Subsystems/subsystemVariables/#motor-speed-variables","title":"Motor speed variables","text":"<pre><code>    public CANSparkMax getShooterAngleMotor() {\nreturn this.shooterAngleMotor;\n}\npublic CANSparkMax getShooterSpeedMotor() {\nreturn this.shooterSpeedMotor;\n}\n</code></pre> <p>These variables represent the speed of the motor and for example can be maniuplated with the line</p> <pre><code>    getShooterAngleMotor().set(0.0);\n</code></pre> <p>This sets the speed of the shooterAngleMotor to zero or stationary</p>"},{"location":"Software/Subsystems/subsystemVariables/#motor-position-variables","title":"Motor position variables","text":"<p>Inside of a motor there are encoders. These encoders are analog sensors that detect how many times a motor has spun in either direction since the motor gained power. A value of one means the motor spun one time. It can also be represented with a decimal, for example if the value is .5 that motor has done half of a rotation.</p> <pre><code>    public double getShooterAngleMotorPosition() {\nreturn this.shooterAngleMotor.getEncoder().getPosition();\n}\npublic double getShooterSpeedMotorPosition() {\nreturn this.shooterSpeedMotor.getEncoder().getPosition();\n}\n</code></pre> <p>You can use the values to sense where the motors are in space. This means that you can spin a motor until it hits your desired location. You can also set the value of the encoder. The reason for this is because ecoder values are not perfect and after a motor is manipulated for a long period of time the encoder value will become inaccurate. A work around to this is to use a strategy called homing which senses when a limit switch is hit and when it is hit it resets the encoder value to zero. The following functions are used to set the encoder values of the two motors to a desired position.</p> <pre><code>    public void setShooterAngleMotorPosition(double position) {\nthis.shooterAngleMotor.getEncoder().setPosition(position);\n}\npublic void setShooterSpeedMotorPosition(double position) {\nthis.shooterSpeedMotor.getEncoder().setPosition(position);\n}\n</code></pre>"},{"location":"Software/Subsystems/subsystemVariables/#sensor-values","title":"Sensor values","text":"<p>The last step in our simple subsystem is a limit switch sensor. The following line gets the value of the sensor and stores it in a variable. When the variable is true that means the switch is being pressed.</p> <pre><code>    public boolean getShooterButton() {\nreturn this.shooterButton.get();\n}\n</code></pre>"},{"location":"Software/Subsystems/subsystemVariables/#final-check-up","title":"Final check up","text":"<p>Your final subsystem should look like this:'</p> <pre><code>public class Shooter extends SubsystemBase {\npublic Shooter() {\nthis.shooterAngleMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterSpeedMotor.setIdleMode(IdleMode.kBrake);\nthis.shooterAngleMotor.setInverted(true);\nthis.shooterSpeedMotor.setInverted(false);\nthis.shooterAngleMotor.setSmartCurrentLimit(50);\nthis.shooterSpeedMotor.setSmartCurrentLimit(75);\n}\npublic CANSparkMax shooterAngleMotor = new CANSparkMax(1, MotorType.kBrushless);\npublic CANSparkMax shooterSpeedMotor = new CANSparkMax(2, MotorType.kBrushless);\nprivate DigitalInput shooterButton = new DigitalInput(1);\npublic enum shooterMotorState {\nON,\nOFF,\nREVERSED\n}\npublic shooterMotorState shooterAngleMotorState = shooterMotorState.OFF;\npublic shooterMotorState shooterSpeedMotorState = shooterMotorState.OFF;\npublic void setShooterAngleMotorState(shooterMotorState state) {\nthis.shooterAngleMotorState = state;\nswitch (state) {\ncase ON:\nthis.shooterAngleMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterAngleMotor.set(0);\nbreak;\ncase REVERSED:\nthis.shooterAngleMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterAngleMotorState(shooterAngleMotorState.OFF);\n}\n}\npublic void setShooterSpeedMotorState(shooterMotorState state) {\nthis.shooterSpeedMotorState = state;\nswitch (state) {\ncase ON:\nthis.shooterSpeedMotor.set(1);\nbreak;\ncase OFF:\nthis.shooterSpeedMotor.set(0);\nbreak;\ncase REVERSED:\nthis.shooterSpeedMotor.set(-1);\nbreak;\ndefault:\nthis.setShooterSpeedMotorState(shooterSpeedMotorState.OFF);\n}\n}\npublic CANSparkMax getShooterAngleMotor() {\nreturn this.shooterAngleMotor;\n}\npublic CANSparkMax getShooterSpeedMotor() {\nreturn this.shooterSpeedMotor;\n}\npublic double getShooterAngleMotorPosition() {\nreturn this.shooterAngleMotor.getEncoder().getPosition();\n}\npublic double getShooterSpeedMotorPosition() {\nreturn this.shooterSpeedMotor.getEncoder().getPosition();\n}\npublic void setShooterAngleMotorPosition(double position) {\nthis.shooterAngleMotor.getEncoder().setPosition(position);\n}\npublic void setShooterSpeedMotorPosition(double position) {\nthis.shooterSpeedMotor.getEncoder().setPosition(position);\n}\npublic boolean getShooterButton() {\nreturn this.shooterButton.get();\n}\n}\n</code></pre> <p>Congratulations you have completed your simple subsystem!</p>"}]}