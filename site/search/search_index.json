{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Repository","text":""},{"location":"Hardware/","title":"Hardware","text":"<p>This page is not completed</p> <p>Learning material for this section has not been created/implemented</p>"},{"location":"Mechanical/","title":"Mechanical","text":"<p>This page is not completed</p> <p>Learning material for this section has not been created/implemented</p>"},{"location":"Software/Commands/","title":"Commands","text":"<p>Abstract</p> <p>Official Documentation on Command Based programming</p> <p>Commands represent actions the robot can take. Commands run when scheduled, until they are interrupted or their end condition is met. Commands are represented in the command-based library by the Command interface. </p> <p>Note</p> <p>Commands are a fundamental building block of almost all of the actions a robot can take. They have to ability to be bound to a button and activate/control different subsystems</p>"},{"location":"Software/Commands/exampleCommand/","title":"exampleCommand","text":"<p>``` java 'Example Command' // Copyright (c) FIRST and other WPILib contributors. // Open Source Software; you can modify and/or share it under the terms of // the WPILib BSD license file in the root directory of this project.</p> <p>package edu.wpi.first.wpilibj.templates.commandbased.commands;</p> <p>import edu.wpi.first.wpilibj.templates.commandbased.subsystems.ExampleSubsystem; import edu.wpi.first.wpilibj2.command.CommandBase;</p> <p>/* An example command that uses an example subsystem. / public class ExampleCommand extends CommandBase {   @SuppressWarnings({\"PMD.UnusedPrivateField\", \"PMD.SingularField\"})   private final ExampleSubsystem m_subsystem;</p> <p>/*    * Creates a new ExampleCommand.    *    * @param subsystem The subsystem used by this command.    /   public ExampleCommand(ExampleSubsystem subsystem) {     m_subsystem = subsystem;     // Use addRequirements() here to declare subsystem dependencies.     addRequirements(subsystem);   }</p> <p>// Called when the command is initially scheduled.   @Override   public void initialize() {}</p> <p>// Called every time the scheduler runs while the command is scheduled.   @Override   public void execute() {}</p> <p>// Called once the command ends or is interrupted.   @Override   public void end(boolean interrupted) {}</p> <p>// Returns true when the command should end.   @Override   public boolean isFinished() {     return false;   } } ```</p>"},{"location":"Software/Commands/properties/","title":"Command Properties","text":"<p>In addition to the four lifecycle methods, each Command in the WPILib library has three properties that can be set to customize its behavior. These properties are defined by getter methods and should always return the same value with no side effects.</p>"},{"location":"Software/Commands/properties/#getrequirements","title":"<code>getRequirements()</code>","text":"<p>Declares any subsystems that the command controls as requirements. This property ensures that no more than one command requires a given subsystem at the same time, preventing conflicts such as two different pieces of code attempting to set the same motor controller to different output values.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>getRequirements()</code> method in the relevant command class</li> <li>Calling <code>addRequirements()</code> method</li> <li>Using the <code>requirements</code> vararg parameter</li> </ul> Adding Requirements to a Command <pre><code>public class ExampleCommand extends CommandBase {\nprivate final ExampleSubsystem m_subsystem;\npublic ExampleCommand(ExampleSubsystem subsystem) {\nm_subsystem = subsystem;\n// Use addRequirements() here to declare subsystem dependencies.\naddRequirements(subsystem);\n}\n}\n</code></pre>"},{"location":"Software/Commands/properties/#runswhendisabled","title":"<code>runsWhenDisabled()</code>","text":"<p>Specifies whether the command may run when the robot is disabled. By default, the value is <code>false</code>, meaning the command will be canceled when the robot is disabled and attempts to schedule it will do nothing. Returning <code>true</code> will allow the command to run and be scheduled when the robot is disabled.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>runsWhenDisabled()</code> method in the relevant command class</li> <li>Using the <code>ignoringDisable</code> decorator</li> </ul> Adding Requirements to a Command <pre><code>public class ExampleCommand extends CommandBase {\npublic ExampleCommand() {\n}\nboolean runsWhenDisabled(){\nreturn true // Allows the command to run while disabled\n}\n}\n</code></pre>"},{"location":"Software/Commands/properties/#getinterruptionbehavior","title":"<code>getInterruptionBehavior()</code>","text":"<p>Defines what happens if another command sharing a requirement is scheduled while this one is running. The default behavior is <code>kCancelSelf</code>, meaning the current command will be canceled and the incoming command will be scheduled successfully. If <code>kCancelIncoming</code> is returned, the incoming command\u2019s scheduling will be aborted and this command will continue running.</p> <p>This property can be set by:</p> <ul> <li>Overriding the <code>getInterruptionBehavior()</code> method in the relevant command class</li> <li>Using the <code>withInterruptBehavior()</code> decorator (Java, C++).</li> </ul>"},{"location":"Software/Commands/structure/","title":"Structure of a Command","text":""},{"location":"Software/Commands/structure/#states","title":"States","text":"<p>When writing a command, you need to specify what the command should do in each of its possible states. To do this, you override the <code>initialize()</code>, <code>execute()</code>, and <code>end()</code> methods. The command should also be able to tell the scheduler when it has finished executing by overriding the <code>isFinished()</code> method.</p> <p>end() Method</p> <p>The <code>end()</code> method actually provides a parameter to check if the command ended normally, or was interrupted.</p> <pre><code>    void end(boolean interrupted){\nif (interrupted == True){\n// The command has been interrupted\n}\nelse{\n// The command has ended as expected\n}\n}\n</code></pre> <p>Tip</p> <p>If a command is not finishing correctly, make sure the <code>isFinished()</code> method returns true when the command should terminate</p>"},{"location":"Software/Commands/structure/#default-behavior","title":"Default Behavior","text":"<p>If you don't want to specify any special behavior for these methods, they are already provided with default behavior. For example, <code>initialize()</code>, <code>execute()</code>, and <code>end()</code> do nothing by default, while <code>isFinished()</code> returns false by default. This creates a command that runs indefinitely until it is interrupted.</p> <p>Methods in Summary</p> <p><code>initialize()</code> --&gt; Called once per scheduling  <code>execute()</code> --&gt; Called every scheduler cycle that the command is scheduled  <code>end()</code> --&gt; Runs once per termination (at the end)  <code>isFinished()</code> --&gt; Called every scheduler cycle (if true --&gt; terminate command)</p>"},{"location":"Software/Commands/Composition/compositions/","title":"Command Compositions","text":"<p>Commands in the command-based library are capable of performing a variety of robot tasks. However, when advanced functionality requiring extended sequences of robot tasks or coordination of multiple robot subsystems is required, users are encouraged to use the command composition functionality.</p> <p>Question</p> <p>Where do you think 4541's Software Team uses compositions the most?</p> One Answer <p>4541, along with pretty much every FRC team, uses command compositions in their autonomous routines. You will learn more about this in the Autonomous Section!</p> <p>Component Commands</p> <p>Component Commands --&gt; Any command</p> <p>A command composition is a combination of one or more commands that allows code to be kept cleaner and simpler. Component commands can be written independently of the code that combines them, reducing complexity.</p> <p>Command compositions are commands themselves, which allows them to be further composed as a recursive composition. This means a command composition can contain other command compositions as components, enabling powerful and concise inline expressions.</p> <p>Commands Themselves</p> <p>Because they are commands themselves, compositions inherit the standard properties of commands.</p>"},{"location":"Software/Commands/Composition/types/","title":"Composition Types","text":""},{"location":"Software/Commands/Composition/types/#repeatedly-composition","title":"Repeatedly Composition","text":"<p>Repeatedly Composition</p> <p>The <code>repeatedly()</code> decorator, backed by the <code>RepeatCommand</code> class restarts the command each time it ends, so that it runs until interrupted.</p> <p>Decorator</p> <pre><code>Command repeats = exampleCommand.repeatedly();\n</code></pre> <p>The command is restarted by calling the command's <code>execute()</code> method again. The command is interrupted by calling the command's <code>end()</code> method. </p> <p>Canceling a Repeatedly Command</p> <pre><code>Command repeats = exampleCommand.repeatedly();\n// Assuming the command is scheduled\nrepeats.cancel();\n</code></pre>"},{"location":"Software/Commands/Composition/types/#sequential-composition","title":"Sequential Composition","text":"<p>Arguably one of the most important composition type, the <code>SequentialCommand</code> class runs a list of commands in sequence. The command ends when the last command in the sequence ends.</p> <p>Sequential Compositions can be created in a variety of ways:</p> Using SequentialCommand Constructor.andThen() DecoratorSequentialCommandGroup Class <pre><code>Command sequential = new SequentialCommand(exampleCommand, exampleCommand2);\n</code></pre> <pre><code>Command sequential = exampleCommand.andThen(exampleCommand2);\n</code></pre> <pre><code>Command sequential = new SequentialCommandGroup(exampleCommand, exampleCommand2, exampleCommand3);\n// OR\nCommand sequential = new SequentialCommandGroup()\nsequential.addCommands(exampleCommand, exampleCommand2, exampleCommand3);\n</code></pre> <p>What's the difference between a SequentialCommand and SequentialCommandGroup?</p> <p>The main difference between the two is that a <code>SequentialCommandGroup</code> allows you to group multiple commands together as a single command. This means that you can create a complex series of actions, like moving an arm, then closing a claw, then raising the arm again, and execute them all as a single command.</p>"},{"location":"Software/Commands/Composition/types/#parallel-composition","title":"Parallel Composition","text":"<p>Another important composition type, the <code>ParallelCommand</code> class runs a list of commands in parallel. The command ends when the last command in the sequence ends.</p> <p>Parallel Compositions can be created in a variety of ways:</p> Using ParallelCommand Constructor.alongWith() DecoratorParallelCommandGroup Class <pre><code>Command parallel = new ParallelCommand(exampleCommand, exampleCommand2);\n</code></pre> <pre><code>Command parallel = exampleCommand.alongWith(exampleCommand2);\n</code></pre> <pre><code>Command parallel = new ParallelCommandGroup(exampleCommand, exampleCommand2, exampleCommand3);\n// OR\nCommand parallel = new ParallelCommandGroup()\nparallel.addCommands(exampleCommand, exampleCommand2, exampleCommand3);\n</code></pre> <p>What's the difference between a ParallelCommand and ParallelCommandGroup?</p> <p><code>ParallelCommandGroup</code> is used when you want to group commands together as a single logical unit. <code>ParallelCommand</code> is used when you want to run multiple commands independently and concurrently.</p>"}]}